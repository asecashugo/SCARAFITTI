<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.4">
  <POU Name="SERIALCOMM" Id="{d61da14d-9742-4da5-a77e-79565503fd61}" SpecialFunc="None">
    <Declaration><![CDATA[(*
SerialCom_InfoSys_Sample3 (v1)
tests a virtual serial com port (or a remote com port).
Functionality is similar to terminal program. 
*)
PROGRAM SERIALCOMM
VAR
	(* communication buffer between application and SerialLineControl *)
	RxBuffer		: ComBuffer;
	TxBuffer		: ComBuffer;

	(* serial line control *)
	fbLineCtrlAds	: SerialLineControlADS;
	bAdsError		: BOOL;
	nAdsErrorID		: UDINT;
	bConnect		: BOOL;
	sNetId			: T_AmsNetId;
	stSerialCfg		: ComSerialConfig;

	(* error history *)
	fbErrHist		: FB_ErrHist := (bEdgeDetect:=FALSE);
	bResetErrHist	: BOOL;

	(* buttons *)
	bContinuousMode	: BOOL;
	bCompareMode	: BOOL;						(* if a loop back adapter is used for testing *)
	bSend			: BOOL;
	(* boolean buttons to change TxData *)
	bIncreaseTxData	: BOOL;
	bResetTxData	: BOOL;
	bInitTxData		: BOOL;
	bAutoIncTxData	: BOOL;						(* increase data on every send *)

	(* data buffer *)
	aRxData				: ARRAY[0..999] OF BYTE;
	nRxDataLen			: UDINT	:= 0;			(* how much data are received at the last cycle *)
	nRxDataSum			: UDINT;				(* how much data are received since reset *)
	aTxData				: ARRAY[0..999] OF BYTE;
	nTxDataLen			: UINT	:= 0;			(* how much data will be sent in this cycle *)
	nTxDataBlockLen		: UINT	:= 0;			(* how much data will be sent in this block *)
	nTxDataSend			: UINT	:= 8;			(* how much data should be sent via bSend command *)
	nTxDataSum			: UDINT;				(* how much data are sent since reset *)
	sSendDataHex		: STRING;
	sSendDataStr		: STRING;
	sSendDataHex_Last	: STRING;
	sSendDataStr_Last	: STRING;

	(* continuous mode *)
	TimerSendDelay	: TON;						(* Continuous Send but wait X cycles before next send *)
	tSendDelay		: TIME	:= T#1000MS;
	fBitsProSec		: REAL;
	fBitsProTel		: REAL;
	fTransPercent	: REAL;

	(* compare mode *)
	aRxDataBlock	: ARRAY[0..999] OF BYTE;
	nRxDataBlockLen	: UDINT;
	aTxDataBlock	: ARRAY[0..999] OF BYTE;
	bCompareError	: BOOL;
	bCompareDone	: BOOL	:=TRUE;
	nCompareCounter	: UDINT;

	(* telegram count *)
	bTelCountEqual	: BOOL	:=TRUE;
	bTelCountError	: BOOL;
	TimerTelWait	: TON;
	tTelWait		: TIME	:=T#5S;

	(* receive data *)
	fbReceiveByte	: ReceiveByte;
	nRcvIndex		: UINT;
	aRcvDataHex		: ARRAY[1..10] OF STRING;
	aRcvDataStr		: ARRAY[1..10] OF STRING;
	aRcvDataLen		: ARRAY[1..10] OF UDINT;
	nRcvDataIdx		: UINT;

	(* send data *)
	fbSend			: SendData;
	nSendCounter	: UDINT;

	bResetCounters	: BOOL;

	I				: UINT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*~~~~~~~~~~~~~~~~ cyclic call of serial background comm. ~~~~~~~~~~~~~~~~~*)
fbLineCtrlAds(
	Connect		:= bConnect,
	SerialCfg	:= stSerialCfg,
	NetId		:= sNetId,
	Timeout		:= ,
	TxBuffer	:= TxBuffer,
	RxBuffer	:= RxBuffer,
	Busy		=> ,
	Error		=> bAdsError,
	ErrorID		=> nAdsErrorID,
	PortOpened	=>
);
IF fbLineCtrlAds.Error THEN
	bCompareMode :=FALSE;
	bContinuousMode :=FALSE;
END_IF
IF bResetErrHist THEN
	bResetErrHist := FALSE;
	fbErrHist.Reset();
END_IF
fbErrHist.AddError(bErr:=fbLineCtrlAds.Error, nErrId:=fbLineCtrlAds.ErrorID, sErrSource:='MAIN.fbLineCtrlAds()' );


(*~~~~~~~~~~~~~~~~~~~~~~~~~~ test functionality ~~~~~~~~~~~~~~~~~~~~~~~~~~*)

(* reset counters *)
IF bResetCounters THEN
	bResetCounters := FALSE;
	nSendCounter := 0;
	nCompareCounter := 0;
	nTxDataSum := 0;
	nRxDataSum := 0;
END_IF

(*+++++++++ Read Data out of ComBuffer to aRxBuffer(user code) +++++++++*)
nRcvIndex	:=0;
REPEAT
	fbReceiveByte(RXbuffer:=RxBuffer);
	IF fbReceiveByte.ByteReceived THEN
		(* evaluate character*)
		aRxData[nRcvIndex] := fbReceiveByte.ReceivedByte;
		nRcvIndex := nRcvIndex + 1;
	END_IF
UNTIL NOT fbReceiveByte.ByteReceived OR (nRcvIndex >= SIZEOF(aRxData)-1) END_REPEAT
IF nRcvIndex>0 THEN
	nRxDataLen := nRcvIndex;
	nRxDataSum := nRxDataSum + nRxDataLen;
	(* copy to visu data array *)
	nRcvDataIdx	:= nRcvDataIdx + 1;
	IF nRcvDataIdx > 10 THEN
		nRcvDataIdx	:= 1;
	END_IF
	aRcvDataLen[nRcvDataIdx] := nRxDataLen;
	aRcvDataHex[nRcvDataIdx] := DATA_TO_HEXSTR(ADR(aRxData[0]), nRxDataLen, FALSE);
	MEMSET(ADR(aRcvDataStr[nRcvDataIdx]), 0, SIZEOF(aRcvDataStr[nRcvDataIdx]));
	MEMCPY(ADR(aRcvDataStr[nRcvDataIdx]), ADR(aRxData[0]), MIN(SIZEOF(aRcvDataStr[nRcvDataIdx]),nRxDataLen));
END_IF

(*++++++++++++++++++++++++ compare mode (loop back) ++++++++++++++++++++++*)
IF bCompareMode THEN
	IF nRcvIndex > 0 THEN
		IF nRxDataBlockLen + nRxDataLen <= SIZEOF(aRxDataBlock) THEN
			MEMCPY(ADR(aRxDataBlock)+nRxDataBlockLen, ADR(aRxData), nRxDataLen );
			nRxDataBlockLen	:= nRxDataBlockLen + nRxDataLen;
			IF nRxDataBlockLen >= nTxDataBlockLen THEN
				nRxDataBlockLen	:= nRxDataBlockLen - nTxDataBlockLen;
				IF MEMCMP(ADR(aRxDataBlock), ADR(aTxDataBlock), nTxDataBlockLen ) <> 0 THEN	(* not equal *)
					bCompareError := TRUE;
				ELSE
					bCompareError := FALSE;
				END_IF
				nCompareCounter := nCompareCounter + 1;
				bCompareDone := TRUE;
			END_IF
		ELSE
			bCompareError := TRUE;
		END_IF
	END_IF

	IF nCompareCounter = nSendCounter AND nRxDataSum = nTxDataSum THEN
		bTelCountEqual := TRUE;
		bTelCountError := FALSE;
	ELSE
		bTelCountEqual := FALSE;
		TimerTelWait(PT:=MAX(tTelWait, tSendDelay));
		IF TimerTelWait.Q THEN
			bTelCountError := TRUE;
		END_IF
	END_IF

	IF bCompareError OR bTelCountError THEN
		bContinuousMode	:=FALSE;
	END_IF
END_IF

(*++++++++++++++++++++++++ continuous mode +++++++++++++++++++++++++++++*)
fBitsProTel		:= UINT_TO_REAL(nTxDataSend) * INT_TO_REAL(1+stSerialCfg.DataBits+MIN(1,stSerialCfg.Parity)+MIN(2,stSerialCfg.StopBits));
tSendDelay		:= MAX(tSendDelay, T#100ms);
fBitsProSec		:= fBitsProTel / (TIME_TO_REAL(tSendDelay)/1000.0);
fTransPercent	:= 100* fBitsProSec / UDINT_TO_REAL(stSerialCfg.Baudrate);
IF bContinuousMode THEN
	TimerSendDelay(IN:=TRUE, PT:=tSendDelay);
	IF TimerSendDelay.Q AND (NOT bCompareMode OR (bCompareMode AND bCompareDone AND bTelCountEqual)) THEN
		bSend := TRUE;
		TimerSendDelay(IN:=FALSE);
		TimerSendDelay(IN:=TRUE);
	END_IF
END_IF

(* new data is input - save it in aTxData and set nTxDataSend *)
IF sSendDataHex_Last <> sSendDataHex THEN
	HEXSTR_TO_DATA(sSendDataHex, ADR(aTxData), SIZEOF(aTxData));
ELSIF sSendDataStr_Last <> sSendDataStr THEN
	MEMCPY(ADR(aTxData), ADR(sSendDataStr), MIN( INT_TO_UDINT(LEN(sSendDataStr)) , SIZEOF(aTxData) ) );
END_IF
(* set TxData values *)
IF bIncreaseTxData OR (bAutoIncTxData AND bSend) THEN
	bIncreaseTxData	:=FALSE;
	FOR I:=0 TO SIZEOF(aTxData)-1 DO
		IF aTxData[I]<255 THEN
			aTxData[I] := aTxData[I]+1;
		ELSE
			aTxData[I] := INT_TO_BYTE(255-aTxData[I]);
		END_IF
	END_FOR
END_IF
IF bResetTxData THEN
	bResetTxData :=FALSE;
	MEMSET(ADR(aTxData), 0, SIZEOF(aTxData));
END_IF
IF bInitTxData THEN
	bInitTxData	:=FALSE;
	FOR I:=0 TO SIZEOF(aTxData)-1 DO
		aTxData[I]	:= UINT_TO_BYTE(I);
	END_FOR
END_IF
sSendDataHex := DATA_TO_HEXSTR(ADR(aTxData[0]), nTxDataSend, FALSE);
MEMCPY(ADR(sSendDataStr), ADR(aTxData[0]), MIN(SIZEOF(sSendDataStr),nTxDataSend));
sSendDataHex_Last := sSendDataHex;
sSendDataStr_Last := sSendDataStr;

(*+++++++++++++++++++++++++++++ send +++++++++++++++++++++++++++++++++++*)
IF bSend THEN
	nTxDataLen		:= nTxDataSend;
	nTxDataBlockLen	:= nTxDataSend;
	FOR I:=0 TO nTxDataBlockLen-1 DO
		CASE stSerialCfg.DataBits OF
		8:
			aTxDataBlock[I] := aTxData[I];
		7:
			aTxDataBlock[I] := aTxData[I] AND 2#01111111;
		6:
			aTxDataBlock[I] := aTxData[I] AND 2#00111111;
		5:
			aTxDataBlock[I] := aTxData[I] AND 2#00011111;
		END_CASE
	END_FOR
	nSendCounter := nSendCounter + 1;
	TimerTelWait(IN:=FALSE);
	TimerTelWait(IN:=TRUE, PT:=MAX(tTelWait, tSendDelay));
	IF bCompareMode THEN
		bCompareDone := FALSE;
	END_IF
	bSend := FALSE;
END_IF
(* Write Data from aTxBuffer(user code) in ComBuffer *)
fbSend(
	pSendData	:= ADR(aTxData),
	Length		:= nTxDataLen,
	TXbuffer	:= TxBuffer,
);
IF NOT fbSend.Busy THEN
	nTxDataSum := nTxDataSum + nTxDataLen;
	nTxDataLen := 0;		(* to avoid a second sending afters successfully sent the telegram *)
END_IF
]]></ST>
    </Implementation>
    <LineIds Name="SERIALCOMM">
      <LineId Id="3" Count="175" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>